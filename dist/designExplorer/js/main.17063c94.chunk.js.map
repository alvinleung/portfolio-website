{"version":3,"sources":["components/designExplorer/viewport/ViewportRenderer.js","components/designExplorer/viewport/Viewport.js","components/designExplorer/viewport/index.js","components/zoomControl/ZoomControl.js","components/zoomControl/index.js","components/designExplorer/designExplorer.js","components/designExplorer/index.js","index.js"],"names":["ViewportRenderer","_canvas","canvas","zooming","_initialized","currentZoom","currentZoomChanges","currentCameraPos","x","y","currentCameraVel","targetCameraPos","imgList","lowFidelityImges","documentColCount","documentWidth","documentHeight","ctx","zoomEndCallback","deltaTime","currentUpdateTime","Date","now","lastUpdateTime","draggingMode","mouseBeginDragPosition","renderImages","imgs","lowQuality","currentCol","currentRow","currentDrawY","currentDrawX","i","length","isRectInBound","width","height","drawImage","w","h","viewportWidthInWorld","viewportHeightInWorld","screenToWorldPos","screenPos","getContext","initialize","_imgList","_documentColCount","initialZoom","map","img","scaleFactor","preRenderCanvas","document","createElement","cacheLowfidelityRender","fardestPointX","fardestPointY","currentRowWidth","currentRowHeight","currentImageWidth","currentImageHeight","calculateDocumentDimension","isInitialized","update","mousePosition","zoom","dragging","mouseScreenPosition","targetZoom","mouseWorldPosBeforeZoom","toFixed","mouseWorldPosAfterZoom","zoomDifference","mousePosInWorld","currentFrameMouseOffset","updateLogic","clearRect","save","scale","translate","isCameraMoving","restore","repaintCanvas","zoomTo","_targetZoom","console","log","pointCameraTo","_targetCameraPos","getCurrentCameraPos","getDocumentWidth","getDocumentHeight","pointCameraToImage","imgIndex","HTMLImageElement","indexOf","cameraX","cumulativeImagePos","warn","onPanEnd","callback","onZoomEnd","worldToScreenPos","worldPos","createViewportRenderer","clamp","value","min","max","Viewport","props","canvasWidth","canvasHeight","useState","mouseHovering","setMouseHovering","useRef","viewportPosition","setViewportPosition","canvasRef","viewportRendererRef","useEffect","gestureStartHandler","e","preventDefault","gestureEndHandler","current","addEventListener","removeEventListener","canvasRect","getBoundingClientRect","window","scrollX","left","scrollY","top","viewportRenderer","loadedImage","sections","currentSection","Image","imgUrl","src","cols","requestAnimationFrame","targetSectionIndex","findIndex","item","title","targetSection","preventDefaultWheelBehaviour","scrollToPan","ctrlKey","metaKey","passive","currentScreenCenterInWorld","style","touchAction","onMouseDown","stopPropagation","onMouseUp","onMouseMove","nativeEvent","pageX","pageY","onMouseOver","onMouseOut","onWheel","newZoomValue","deltaY","onZoom","deltaX","ref","ZoomControl","defaultZoomLevel","zoomLevel","Math","floor","className","onClick","onZoomChange","newZoom","DesignExplorer","setZoomLevel","innerWidth","innerHeight","viewportSize","setWindowSize","viewingSection","setCurrentViewingSection","zoomInteractionHint","setZoomInteractionHint","zoomHintTimer","mouseInComponent","containerRef","sectionNames","val","index","scrollHandler","ctrlkey","clearTimeout","setTimeout","windowResizeHandler","offsetWidth","offsetHeight","hashChangeHandler","decodeURIComponent","location","hash","split","onMouseEnter","navigator","platform","querySelectorAll","forEach","elm","allImgTag","srcList","colCountAttribute","parseInt","getAttribute","colInitialZoomAttribute","ReactDOM","render"],"mappings":"uQAodeA,MA7cf,SAA0BC,GAExB,IA6BIC,EA3BAC,GAAU,EAGVC,GAAe,EAGfC,EAAc,EACdC,EAAqB,EAGrBC,EAAmB,CAAEC,EAAG,EAAGC,EAAG,GAC9BC,EAAmB,CAAEF,EAAG,EAAGC,EAAG,GAC9BE,EAAkB,CAAEH,EAAG,EAAGC,EAAG,GAM7BG,EAAU,GACVC,EAAmB,GAGnBC,EAAmB,EACnBC,EAAgB,EAChBC,EAAiB,EAInBC,EAAM,KAGJC,EAAkB,aAIlBC,EAAY,EAEZC,EAAoBC,KAAKC,MACzBC,EAAiBH,EAiJjBI,GAAe,EAEfC,EAAyB,CAAEjB,EAAG,EAAGC,EAAG,GAuKxC,SAASiB,EAAaT,EAAKU,EAAMC,GAQ/B,IAPA,IAAIC,EAAa,EACbC,EAAa,EAIbC,EAAe,EACfC,EAAe,EACVC,EAAI,EAAGA,EAAIN,EAAKO,OAAQD,IAAK,CACbE,EACrBH,EACAD,EACAJ,EAAKM,GAAGG,MACRT,EAAKM,GAAGI,UAIJT,GAAcvB,EAAc,GAE9BY,EAAIqB,UACFzB,EAAiBoB,GACjBD,EACAD,EACAJ,EAAKM,GAAGG,MACRT,EAAKM,GAAGI,QAIVpB,EAAIqB,UAAUX,EAAKM,GAAID,EAAcD,IAOrCJ,EAAKM,GAAGI,OA/BS,IA+BkBP,EAAaH,EAAKM,GAAGI,QAG5DL,GAAgBL,EAAKM,GAAGG,MAlXC,EAoXrBP,EAAaf,EAAmB,EAGlCe,KAKAE,GAAgBD,EA5XO,EA6XvBA,IAGAE,EAAe,EACfH,EAAa,EAGbC,EAAa,IAWnB,SAASK,EAAc3B,EAAGC,EAAG8B,EAAGC,GAC9B,IAAIC,EAAuBvC,EAAOkC,MAAQ/B,EACtCqC,EAAwBxC,EAAOmC,OAAShC,EAC5C,OACEG,EAAID,EAAiBC,EAAIiC,GACzBjC,EAAI+B,EAAIhC,EAAiBC,GACzBC,EAAIF,EAAiBE,EAAIiC,GACzBjC,EAAI+B,EAAIjC,EAAiBE,EAQ7B,SAASkC,EAAiBC,GACxB,MAAO,CACLpC,EAAGoC,EAAUpC,EAAIH,EAAcE,EAAiBC,EAChDC,EAAGmC,EAAUnC,EAAIJ,EAAcE,EAAiBE,GAkBpD,OA7ZA,SAAgCR,GAK9B,OAFAgB,GADAf,EAASD,GACI4C,WAAW,MAEjB,CACLC,WAAY,SAAUC,EAAUC,EAAmBC,GACjDnC,EAAmBkC,EAEfC,IAAa5C,EAAc4C,GAgFnCpC,EA9E2BkC,EA8EHG,KAAI,SAACC,GAAD,OA4M9B,SAAgCA,EAAKC,GACnC,IAAMC,EAAkBC,SAASC,cAAc,UAQ/C,OAPAF,EAAgBjB,MAAQe,EAAIf,MAAQgB,EACpCC,EAAgBhB,OAASc,EAAId,OAASe,EAEtCC,EACGR,WAAW,MACXP,UAAUa,EAAK,EAAG,EAAGE,EAAgBjB,MAAOiB,EAAgBhB,QAExDgB,EArN8BG,CAAuBL,EAAK,OA7E7DvC,EAAUmC,EAgFhB,SAAoCnC,GAOlC,IANA,IAAI6C,EAAgB,EAChBC,EAAgB,EAEhB7B,EAAa,EACb8B,EAAkB,EAClBC,EAAmB,EACd3B,EAAI,EAAGA,EAAIrB,EAAQsB,OAAQD,IAAK,CAEvC,IAAM4B,EAAoBjD,EAAQqB,GAAGG,MAC/B0B,EAAqBlD,EAAQqB,GAAGI,OAGlCyB,EAAqBF,IACvBA,EAAmBE,GAErBH,GAAmBE,EAlIM,EAqIrBhC,EAAaf,EAAmB,EAIlCe,KAKI8B,EAAkBF,IAAeA,EAAgBE,GAGrDD,GAAiBE,EAjJM,EAoJvBD,EAAkB,EAClBC,EAAmB,EACnB/B,EAAa,GAIbA,EAAaf,EAAmB,IAClC4C,GAAiBE,EA3JQ,GA6J3B7C,EAAgB0C,EAChBzC,EAAiB0C,EA3HbK,CAA2BhB,GAC3B3C,GAAe,GAEjB4D,cAAe,WACb,OAAO5D,GAET6D,OAAQ,SAAUC,EAAeC,EAAMC,GA2QzChD,EAAoBC,KAAKC,MAEzBH,EAnSiB,IAkSDC,EAAoBG,GAEpCA,EAAiBH,EAhJnB,SAAqBiD,EAAqBC,EAAYF,GACpD,IAAMG,EAA0B5B,EAAiB0B,GAOjD,GAHAhE,GADAC,EAAkD,IAA5BgE,EAAajE,GAIE,GAAjCC,EAAmBkE,QAAQ,GAAS,CACtCrE,GAAU,EAEV,IAAMsE,EAAyB9B,EAAiB0B,GAE1CK,EAAiB,CACrBlE,EAAG+D,EAAwB/D,EAAIiE,EAAuBjE,EACtDC,EAAG8D,EAAwB9D,EAAIgE,EAAuBhE,GAUxDF,EAAiBC,GAAKkE,EAAelE,EACrCD,EAAiBE,GAAKiE,EAAejE,EAGrCE,EAAgBH,GAAKkE,EAAelE,EACpCG,EAAgBF,GAAKiE,EAAejE,OAEhCN,GAASe,EAAgBb,GAC7BF,GAAU,EAGZ,GAAIiE,EAAU,CACZ,IAAMO,EAAkBhC,EAAiB0B,GAEpC7C,IAEHA,GAAe,EAEK,CAClBhB,EAAGmE,EAAgBnE,EAAID,EAAiBC,EACxCC,EAAGkE,EAAgBlE,EAAIF,EAAiBE,GAE1CgB,EAAyBkD,GAG3B,IAAMC,EAA0B,CAC9BpE,EAAGmE,EAAgBnE,EAAIiB,EAAuBjB,EAC9CC,EAAGkE,EAAgBlE,EAAIgB,EAAuBhB,GAEhDE,EAAgBH,EAAID,EAAiBC,EAAIoE,EAAwBpE,EACjEG,EAAgBF,EAAIF,EAAiBE,EAAImE,EAAwBnE,OAEjEe,GAAe,EAKjBd,EAAiBF,EAA+C,IAA1CG,EAAgBH,EAAID,EAAiBC,GAC3DE,EAAiBD,EAA+C,IAA1CE,EAAgBF,EAAIF,EAAiBE,GAI3DF,EAAiBC,GAAKE,EAAiBF,EAAIW,EAC3CZ,EAAiBE,GAAKC,EAAiBD,EAAIU,EAhMvC0D,CAAYX,EAAeC,EAAMC,GAyNvC,SAAuBlE,EAAQe,EAAKU,EAAM0C,EAAqBF,GAE7DlD,EAAI6D,UAAU,EAAG,EAAG5E,EAAOkC,MAAOlC,EAAOmC,QAGzCpB,EAAI8D,OAGJ9D,EAAI+D,MAAM3E,EAAaA,GACvBY,EAAIgE,WAAW1E,EAAiBC,GAAID,EAAiBE,GAMjDN,GAsHN,WACE,OACmC,GAAjCO,EAAiBF,EAAEgE,QAAQ,IAA4C,GAAjC9D,EAAiBD,EAAE+D,QAAQ,GAxHpDU,GACbxD,EAAaT,EAAKU,GAAM,GAExBD,EAAaT,EAAKU,GAAM,GAe1BV,EAAIkE,WA/TW,EAsEXC,CAAclF,EAAQe,EAAKL,IAG7ByE,OAAQ,SAAUC,GAEhBC,QAAQC,IAAI,sBAAwBF,IAGtCG,cAAe,SAAUC,GACvB/E,EAAgBH,EAAIkF,EAAiBlF,EACrCG,EAAgBF,EAAIiF,EAAiBjF,GAGvCkF,oBAAqB,WACnB,MAAO,CACLnF,EAAGD,EAAiBC,EACpBC,EAAGF,EAAiBE,IAGxBmF,iBAAkB,WAChB,OAAO7E,GAET8E,kBAAmB,WACjB,OAAO7E,GAGT8E,mBAAoB,SAAU3C,GAC5B,IAAM4C,EACJ5C,aAAe6C,iBAAmBpF,EAAQqF,QAAQ9C,GAAOA,EAE3D,GAAKvC,EAAQmF,GAAb,CAUA,IAJA,IAAMG,GAAWhG,EAAOkC,MAAQ/B,EAAc,EAG1C8F,EAAqB,EAChBlE,EAAI,EAAGA,EAAI8D,EAAU9D,IAC5BkE,GAAsBvF,EAAQqB,GAAGI,OArFZ,EAuFvB1B,EAAgBH,EAAI0F,EACpBvF,EAAgBF,EAAI0F,OAblBZ,QAAQa,KAAK,wBAA0BjD,IAe3CkD,SAAU,SAAUC,GACDA,GAEnBC,UAAW,SAAUD,GACnBpF,EAAkBoF,GAEpBE,iBAAkB,SAAUC,GAC1B,OAoUN,SAA0BA,GAExB,MAAO,CACLjG,GAAIiG,EAASjG,EAAID,EAAiBC,GAAKH,EACvCI,GAAIgG,EAAShG,EAAIF,EAAiBE,GAAKJ,GAxU9BmG,CAAiBC,IAE1B9D,iBAAkB,SAAUC,GAC1B,OAAOD,EAAiBC,KA+UvB8D,CAAuBzG,I,KC5LhC,SAAS0G,EAAMC,EAAOC,EAAKC,GACzB,OAAIF,EAAQC,EAAYA,EACpBD,EAAQE,EAAYA,EACjBF,EAiBMG,ICzSAA,EDcf,SAAkBC,GAChB,IAAMC,EAAcD,EAAM5E,MACpB8E,EAAeF,EAAM3E,OAFJ,EAImB8E,oBAAS,GAJ5B,mBAIhBC,EAJgB,KAIDC,EAJC,KAUjBlD,EAAOmD,iBAAO,GAKdlD,EAAWkD,kBAAO,GAClBpD,EAAgBoD,iBAAO,CAAE9G,EAAG,EAAGC,EAAG,IAhBjB,EAmByB0G,mBAAS,CAAE3G,EAAG,EAAGC,EAAG,IAnB7C,mBAmBhB8G,EAnBgB,KAmBEC,EAnBF,KAoBjBC,EAAYH,iBAAO,MAGnBI,EAAsBJ,iBAAO,MA+MnC,OA3IAK,qBAAU,WACR,SAASC,EAAoBC,GAC3BA,EAAEC,iBAKJ,SAASC,EAAkBF,GACzBA,EAAEC,iBAKJ,OAFAL,EAAUO,QAAQC,iBAAiB,aAAcL,GACjDH,EAAUO,QAAQC,iBAAiB,WAAYF,GACxC,WACLN,EAAUO,QAAQE,oBAAoB,aAAcN,GACpDH,EAAUO,QAAQE,oBAAoB,WAAYH,MAEnD,IAEHJ,qBAAU,WAER,IAAMQ,EAAaV,EAAUO,QAAQI,wBACrCZ,EAAoB,CAGlBhH,EAAG6H,OAAOC,QAAUH,EAAWI,KAC/B9H,EAAG4H,OAAOG,QAAUL,EAAWM,QAIhC,IAEHd,qBAAU,WAER,IAAMe,EAAmB1I,EAAiByH,EAAUO,SAGhDW,EAAc,EACZ/H,EAAUoG,EAAM4B,SAAS1F,KAAI,SAAC2F,GAIlC,IAAM1F,EAAM,IAAI2F,MACVC,EAASF,EAAeG,IAiB9B,OAhBA7F,EAAI6F,IAAMD,EACV5F,EAAI8E,iBAAiB,QAAQ,WAC3B1C,QAAQC,IAAI,0BAA4BuD,KACxCJ,IAEoB/H,EAAQsB,UAEX,EAEfqD,QAAQC,IAAI,kDAGZkD,EAAiB5F,WAAWlC,EAASoG,EAAMiC,KAAM9E,EAAK6D,aAInD7E,MAIM,SAATc,EAAU9C,GACVuH,EAAiB1E,iBACnB0E,EAAiBzE,OACfC,EAAc8D,QACd7D,EAAK6D,QACL5D,EAAS4D,SAIbkB,sBAAsBjF,GAGxBA,GAEAyD,EAAoBM,QAAUU,IAC7B,IAEHf,qBAAU,WAGR,IAAMwB,EAAqBnC,EAAM4B,SAASQ,WACxC,SAACC,GAAD,OAAUA,EAAKC,QAAUtC,EAAMuC,iBAEjChE,QAAQC,IAAI,4BAA8BwB,EAAMuC,eAGhD7B,EAAoBM,QAAQlC,mBAAmBqD,KAC9C,CAACnC,EAAMuC,gBAEV5B,qBAAU,WACR,GAAKP,EAAL,CACA,IAAMoC,EAA+B,SAAC3B,IAIhCb,EAAMyC,aAAe5B,EAAE6B,SAAW7B,EAAE8B,UAAS9B,EAAEC,kBAKrD,OAHAO,OAAOJ,iBAAiB,QAASuB,EAA8B,CAC7DI,SAAS,IAEJ,WACLvB,OAAOH,oBAAoB,QAASsB,OAErC,CAACpC,IAGJO,qBAAU,WACR,GAAIX,EAAM1C,aACRH,EAAK6D,QAAUhB,EAAM1C,YAGhB8C,GAAe,CAElB,IAAMyC,EAA6BnC,EAAoBM,QAAQrF,iBAC7D,CACEnC,EAAGyG,EAAc,EACjBxG,EAAGyG,EAAe,IAItBhD,EAAc8D,QAAUN,EAAoBM,QAAQxB,iBAAiB,CACnEhG,EAAGmG,EACDkD,EAA2BrJ,EAC3ByG,EAAc,EACdS,EAAoBM,QAAQpC,oBAE9BnF,EAAGkG,EACDkD,EAA2BpJ,EAC3ByG,EAAe,EACfQ,EAAoBM,QAAQnC,0BAKnC,CAACmB,EAAM1C,aAER,4BACEwF,MAAO,CAAEC,YAAa,QACtBC,YAhNJ,SAA0BnC,GAExBA,EAAEoC,kBACFpC,EAAEC,iBAGF1D,EAAS4D,SAAU,GA2MjBkC,UAxMJ,SAAwBrC,GAEtBzD,EAAS4D,SAAU,GAuMjBmC,YApKJ,SAA0BtC,GAIxB3D,EAAc8D,QAAU,CACtBxH,EAAGqH,EAAEuC,YAAYC,MAAQ9C,EAAiB/G,EAC1CC,EAAGoH,EAAEuC,YAAYE,MAAQ/C,EAAiB9G,IA+J1C8J,YA1JJ,SAA0B1C,GAExBR,GAAiB,IAyJfmD,WAtJJ,SAAyB3C,GACvBR,GAAiB,IAsJfoD,QAvMJ,SAA2B5C,GAIzB,GAAIA,EAAEuC,YAAYV,SAAW7B,EAAEuC,YAAYT,QAAS,CAElD,IAAMe,EACJvG,EAAK6D,QAvCe,KAuCLH,EAAEuC,YAAYO,OAG/BxG,EAAK6D,QAAUrB,EAAM+D,EAxCR,GADA,KA4CT1D,EAAM4D,QAAQ5D,EAAM4D,OAAOzG,EAAK6D,cAEpC,GAAIhB,EAAMyC,YAAa,CAErB,IAAMlJ,EAAmBmH,EAAoBM,QAAQrC,sBAErD+B,EAAoBM,QAAQvC,cAAc,CACxCjF,EACED,EAAiBC,EA9CF,EA+CdqH,EAAEuC,YAAYS,OAA6B1G,EAAK6D,QACnDvH,EACEF,EAAiBE,EAjDF,EAkDdoH,EAAEuC,YAAYO,OAA6BxG,EAAK6D,UAIzD,OAAO,GA2KL8C,IAAKrD,EACLrF,MAAO6E,EACP5E,OAAQ6E,K,YE3MC6D,ICpDAA,EDGf,SAAqB/D,GACnB,IAAMgE,EAAmBhE,EAAMgE,iBAC3BhE,EAAMgE,iBACN,IACEC,EAAYC,KAAKC,MAAMnE,EAAMiE,WAuBnC,OACE,yBACEG,UACEH,IAAcD,EACV,eACA,sCAGN,4BAAQI,UAAU,sBAAsBC,QA1B5C,WACMrE,EAAMsE,cAActE,EAAMsE,aAAaN,KAyBzC,cAGA,4BAAQK,QA1BZ,WAEE,IACME,EAAUN,EADYA,EATT,MAWfjE,EAAMsE,cACRtE,EAAMsE,aAAaC,EAXN,QAWsCA,KAqBnD,KACA,yBAAKH,UAAU,uBAAuBH,EAAtC,KACA,4BAAQI,QArBZ,WAEE,IACME,EAAUN,EADYA,EAhBT,MAkBfjE,EAAMsE,cACRtE,EAAMsE,aAAaC,EAjBN,MAiBsCA,KAgBnD,OE6HSC,ICxKAA,EDMf,SAAwBxE,GACtB,IAAMpG,EAAUoG,EAAMgC,IAEhBgC,EAAmBhE,EAAM/D,aAAe,IAHjB,EAIKkE,mBAASH,EAAM/D,aAAe,KAJnC,mBAItBgI,EAJsB,KAIXQ,EAJW,OAKStE,mBAAS,CAC7C/E,MAAOiG,OAAOqD,WACdrJ,OAAQgG,OAAOsD,cAPY,mBAKtBC,EALsB,KAKRC,EALQ,OAUsB1E,mBAAS,IAV/B,mBAUtB2E,EAVsB,KAUNC,EAVM,OAcyB5E,oBAAS,GAdlC,mBActB6E,EAdsB,KAcDC,EAdC,KAevBC,EAAgB5E,iBAAO,MACvB6E,EAAmB7E,kBAAO,GAE1B8E,EAAe9E,iBAAO,MAEtB+E,EAAe,CACnB,qBACA,sBACA,sBACA,cACA,oBACA,8BACA,mBAEEzD,EAAWhI,EAAQsC,KAAI,SAACoJ,EAAKC,GAC/B,MAAO,CACLjD,MAAO+C,EAAaE,GACpBvD,IAAKsD,MA6BT,SAASE,EAAc3E,IAEjBsE,EAAiBnE,SAAaH,EAAE4E,SAAY5E,EAAE8B,QAgBhDsC,GAAuB,IAfvBA,GAAuB,GAOM,MAAzBC,EAAclE,SAAiB0E,aAAaR,EAAclE,SAG9DkE,EAAclE,QAAU2E,YACtB,kBAAMV,GAAuB,KA9DZ,MAsEvB,SAASW,IAEPf,EAAc,CACZzJ,MAAOgK,EAAapE,QAAQ6E,YAC5BxK,OAAQ+J,EAAapE,QAAQ8E,eAIjC,SAASC,IACPhB,EACEiB,mBAAmB3E,OAAO4E,SAASC,KAAKC,MAAM,KAAK,KAsBvD,OAnBAxF,qBAAU,WAIR,OAHAU,OAAOJ,iBAAiB,SAAU2E,GAClCvE,OAAOJ,iBAAiB,aAAc8E,GACtC1E,OAAOJ,iBAAiB,SAAUuE,GAC3B,WACLnE,OAAOH,oBAAoB,SAAU0E,GACrCvE,OAAOH,oBAAoB,aAAc6E,GACzC1E,OAAOH,oBAAoB,SAAUsE,MAEtC,IAGH7E,qBAAU,WACRkE,EAAc,CACZzJ,MAAOgK,EAAapE,QAAQ6E,YAC5BxK,OAAQ+J,EAAapE,QAAQ8E,iBAE9B,CAACV,IAGF,yBACEtB,IAAKsB,EACLhB,UAAU,4BACVgC,aAzEJ,WACEjB,EAAiBnE,SAAU,GAyEzBwC,WAvEJ,WACE2B,EAAiBnE,SAAU,IAwEzB,yBAAKoD,UAAU,eAAf,uCACA,kBAAC,EAAD,CACEH,UAAWA,EACXK,aApEN,SAA2BL,GACzBQ,EAAaR,IAoETD,iBAAkBA,IAEpB,yBAAKI,UAAU,sBACb,kBAAC,EAAD,CACEhJ,MAAOwJ,EAAaxJ,MACpBC,OAAQuJ,EAAavJ,OACrB2G,IAAKpI,EACLgI,SAAUA,EACVW,cAAeuC,EACfxH,WAAY2G,EAAY,IACxBL,OAnFR,SAA6BzG,GAC3BsH,EAAoB,IAAPtH,IAmFP8E,KAAMjC,EAAMiC,KAAOjC,EAAMiC,KAAO,EAChCQ,cAAazC,EAAMyC,aAAczC,EAAMyC,eAG3C,yBACE2B,UACEY,EACI,wBACA,uDAtGHqB,UAAUC,SAASrH,QAAQ,QAAU,GAyGxB,iEA7GboH,UAAUC,SAASrH,QAAQ,QAAU,GA8GtB,sEEnI1BoC,OAAOJ,iBAAiB,QAAQ,WACH3E,SAASiK,iBAAiB,oBAClCC,SAAQ,SAACC,GAO1B,IAHA,IAAMC,EAAYD,EAAIF,iBAAiB,OAEnCI,EAAU,GACL1L,EAAI,EAAGA,EAAIyL,EAAUxL,OAAQD,IACpC0L,EAAQ1L,GAAKyL,EAAUzL,GAAG+G,IAK5B,IAAM4E,EAAoBC,SAASJ,EAAIK,aAAa,cAAgB,GAE9DC,EAA0BF,SAC9BJ,EAAIK,aAAa,mBAAqB,KAGxCvI,QAAQC,IAAI,QACZwI,IAASC,OACP,kBAAC,EAAD,CACEjF,IAAK2E,EACL1E,KAAM2E,EACNnE,aAAa,EACbxG,YAAa8K,IAEfN,W","file":"static/js/main.17063c94.chunk.js","sourcesContent":["/*\n * this componenet takes in the input controlling signal\n * from Viewport and render it on screen.\n */\n\nconst DEBUG_MODE = false;\n\nfunction ViewportRenderer(_canvas) {\n  // global variables in this component\n  let mousePosition = { x: 0, y: 0 };\n  let zoom = 0;\n  let zooming = false;\n\n  // Whether the component is initialised\n  let _initialized = false;\n\n  // ZOOM\n  let currentZoom = 1;\n  let currentZoomChanges = 0; // basically velocity of zoom\n\n  // CAMERA\n  let currentCameraPos = { x: 0, y: 0 };\n  let currentCameraVel = { x: 0, y: 0 };\n  let targetCameraPos = { x: 0, y: 0 };\n\n  // mouse\n  let mouseDragBeginPosition = { x: 0, y: 0 };\n\n  // IMAGE OPTIMISATION\n  let imgList = [];\n  let lowFidelityImges = [];\n  const paddingBetweenImages = 0;\n  let DOCUMENT_PADDING = 100;\n  let documentColCount = 2;\n  let documentWidth = 0;\n  let documentHeight = 0;\n\n  // ref to the canvas\n  let canvas,\n    ctx = null;\n\n  // callback functions\n  let zoomEndCallback = () => {};\n  let panEndCallback = () => {};\n\n  // update functions\n  let deltaTime = 0;\n  let realDeltaTime = 0;\n  let currentUpdateTime = Date.now();\n  let lastUpdateTime = currentUpdateTime;\n  const TIME_SCALE = 0.1;\n\n  // interface for the renderer\n  function createViewportRenderer(_canvas) {\n    // initialize the canvas\n    canvas = _canvas;\n    ctx = canvas.getContext(\"2d\");\n\n    return {\n      initialize: function (_imgList, _documentColCount, initialZoom) {\n        documentColCount = _documentColCount;\n\n        if (initialZoom) currentZoom = initialZoom;\n\n        generateOptimizedImage(_imgList);\n        imgList = _imgList;\n        calculateDocumentDimension(_imgList);\n        _initialized = true;\n      },\n      isInitialized: function () {\n        return _initialized;\n      },\n      update: function (mousePosition, zoom, dragging) {\n        updateDeltaTime();\n        updateLogic(mousePosition, zoom, dragging);\n        repaintCanvas(canvas, ctx, imgList, mousePosition, zoom);\n      },\n\n      zoomTo: function (_targetZoom) {\n        // currentZoom = _targetZoom;\n        console.log(\"zooming to target: \" + _targetZoom);\n      },\n\n      pointCameraTo: function (_targetCameraPos) {\n        targetCameraPos.x = _targetCameraPos.x;\n        targetCameraPos.y = _targetCameraPos.y;\n      },\n\n      getCurrentCameraPos: function () {\n        return {\n          x: currentCameraPos.x,\n          y: currentCameraPos.y,\n        };\n      },\n      getDocumentWidth: function () {\n        return documentWidth;\n      },\n      getDocumentHeight: function () {\n        return documentHeight;\n      },\n\n      pointCameraToImage: function (img) {\n        const imgIndex =\n          img instanceof HTMLImageElement ? imgList.indexOf(img) : img;\n\n        if (!imgList[imgIndex]) {\n          console.warn(\"Can't find img index \" + img);\n          return;\n        }\n\n        // calculate the center position\n        const cameraX = -canvas.width / currentZoom / 2;\n\n        // calculate where the camera should scroll to\n        let cumulativeImagePos = 0;\n        for (let i = 0; i < imgIndex; i++) {\n          cumulativeImagePos += imgList[i].height + paddingBetweenImages;\n        }\n        targetCameraPos.x = cameraX;\n        targetCameraPos.y = cumulativeImagePos;\n      },\n      onPanEnd: function (callback) {\n        panEndCallback = callback;\n      },\n      onZoomEnd: function (callback) {\n        zoomEndCallback = callback;\n      },\n      worldToScreenPos: function (worldPos) {\n        return worldToScreenPos(worldPos);\n      },\n      screenToWorldPos: function (screenPos) {\n        return screenToWorldPos(screenPos);\n      },\n    };\n  }\n\n  // ===============================================================\n  // begin main cycle\n  // ===============================================================\n\n  // INITIALIZATION\n  function generateOptimizedImage(imgs) {\n    lowFidelityImges = imgs.map((img) => cacheLowfidelityRender(img, 0.5));\n  }\n\n  function calculateDocumentDimension(imgList) {\n    let fardestPointX = 0;\n    let fardestPointY = 0;\n\n    let currentCol = 0;\n    let currentRowWidth = 0;\n    let currentRowHeight = 0;\n    for (let i = 0; i < imgList.length; i++) {\n      // grab the image dimension\n      const currentImageWidth = imgList[i].width;\n      const currentImageHeight = imgList[i].height;\n\n      // check if it need to update the row's height\n      if (currentImageHeight > currentRowHeight)\n        currentRowHeight = currentImageHeight;\n      // increment col width\n      currentRowWidth += currentImageWidth + paddingBetweenImages;\n\n      // determine whether the image is at the end of row\n      if (currentCol < documentColCount - 1) {\n        // if the image is not end of row...\n\n        // increment the col position\n        currentCol++;\n      } else {\n        // when end of row...\n\n        // update the document width if necessary\n        if (currentRowWidth > fardestPointX) fardestPointX = currentRowWidth;\n\n        // increment document height by the row height\n        fardestPointY += currentRowHeight + paddingBetweenImages;\n\n        // clean up, reset all the current row variables to prepare for next row\n        currentRowWidth = 0;\n        currentRowHeight = 0;\n        currentCol = 0;\n      }\n    }\n    // add the last row\n    if (currentCol < documentColCount - 1)\n      fardestPointY += currentRowHeight + paddingBetweenImages;\n\n    documentWidth = fardestPointX;\n    documentHeight = fardestPointY;\n\n    // console.log(documentHeight);\n  }\n\n  let draggingMode = false;\n  let cameraMouseOffset = { x: 0, y: 0 };\n  let mouseBeginDragPosition = { x: 0, y: 0 };\n  // UPDATE\n  function updateLogic(mouseScreenPosition, targetZoom, dragging) {\n    const mouseWorldPosBeforeZoom = screenToWorldPos(mouseScreenPosition); // the position where the mouse is point in the world\n\n    // update zoom\n    currentZoomChanges = (targetZoom - currentZoom) * 0.2; // add a little bit of trailing effect on the zoom\n    currentZoom += currentZoomChanges;\n\n    // if it's zooming\n    if (currentZoomChanges.toFixed(3) != 0) {\n      zooming = true;\n      // reposition the camera base on where the mouse is pointing\n      const mouseWorldPosAfterZoom = screenToWorldPos(mouseScreenPosition);\n\n      const zoomDifference = {\n        x: mouseWorldPosBeforeZoom.x - mouseWorldPosAfterZoom.x,\n        y: mouseWorldPosBeforeZoom.y - mouseWorldPosAfterZoom.y,\n      };\n\n      // trasnlate the camera base on the difference\n      const cameraOffsetAmount = {\n        x: zoomDifference.x,\n        y: zoomDifference.y,\n      };\n\n      // tweak the camera position so that it zooms in at the mouse\n      currentCameraPos.x += zoomDifference.x;\n      currentCameraPos.y += zoomDifference.y;\n\n      // also offset the target camera pos too\n      targetCameraPos.x += zoomDifference.x;\n      targetCameraPos.y += zoomDifference.y;\n    } else {\n      if (zooming) zoomEndCallback(currentZoom);\n      zooming = false;\n    }\n\n    if (dragging) {\n      const mousePosInWorld = screenToWorldPos(mouseScreenPosition);\n\n      if (!draggingMode) {\n        // getting into dragging mode\n        draggingMode = true;\n        // calculate the difference between mouse and camera pos\n        cameraMouseOffset = {\n          x: mousePosInWorld.x - currentCameraPos.x,\n          y: mousePosInWorld.y - currentCameraPos.y,\n        };\n        mouseBeginDragPosition = mousePosInWorld;\n      }\n\n      const currentFrameMouseOffset = {\n        x: mousePosInWorld.x - mouseBeginDragPosition.x,\n        y: mousePosInWorld.y - mouseBeginDragPosition.y,\n      };\n      targetCameraPos.x = currentCameraPos.x - currentFrameMouseOffset.x;\n      targetCameraPos.y = currentCameraPos.y - currentFrameMouseOffset.y;\n    } else {\n      draggingMode = false;\n    }\n\n    // update update the camera velocty base on the target position\n\n    currentCameraVel.x = (targetCameraPos.x - currentCameraPos.x) * 0.2; // add alittle bit of trailing effect\n    currentCameraVel.y = (targetCameraPos.y - currentCameraPos.y) * 0.2; // add alittle bit of trailing effect\n\n    // interpolate the camera position\n    // constraint the camera movement if it's within bound\n    currentCameraPos.x += currentCameraVel.x * deltaTime;\n    currentCameraPos.y += currentCameraVel.y * deltaTime;\n  }\n\n  function canMoveHorizontally() {\n    return (\n      !(currentCameraPos.x < 0 && currentCameraVel.x < 0) &&\n      !(\n        currentCameraPos.x + canvas.width / currentZoom > documentWidth &&\n        currentCameraVel.x > 0\n      )\n    );\n  }\n\n  function canMoveVertically() {\n    return (\n      !(currentCameraPos.y < 0 && currentCameraVel.y < 0) &&\n      !(\n        currentCameraPos.y + canvas.height / currentZoom > documentHeight &&\n        currentCameraVel.y > 0\n      )\n    );\n  }\n\n  let prevZoom = 0;\n  // RENDER\n  function repaintCanvas(canvas, ctx, imgs, mouseScreenPosition, zoom) {\n    // clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // prepare transformation for camera movement transformation\n    ctx.save();\n\n    // move camera\n    ctx.scale(currentZoom, currentZoom);\n    ctx.translate(-currentCameraPos.x, -currentCameraPos.y); // move everything to center\n    // zoom in a point using scale and translate\n    //https://stackoverflow.com/questions/2916081/zoom-in-on-a-point-using-scale-and-translate\n\n    // render images in low quality mode when there is camera movement\n    // to make the animation look smoother\n    if (zooming || isCameraMoving()) {\n      renderImages(ctx, imgs, true);\n    } else {\n      renderImages(ctx, imgs, false);\n    }\n\n    // screen to world pos projection is working\n\n    if (DEBUG_MODE) {\n      // render mouse world position\n      const mouseWorldPos = screenToWorldPos(mouseScreenPosition);\n      ctx.beginPath();\n      ctx.rect(mouseWorldPos.x, mouseWorldPos.y, 10, 10);\n      ctx.fillStyle = \"blue\";\n      ctx.fill();\n\n      // reset transformation\n    }\n    ctx.restore();\n\n    // display the debug information and round to 2 deicmals\n    if (DEBUG_MODE) {\n      renderPos(ctx, \"mouse screen\", mouseScreenPosition, 20, 50);\n      renderPos(ctx, \"camera pos\", currentCameraPos, 20, 80);\n      ctx.fillText(\"zoom \" + currentZoom.toFixed(2), 20, 110);\n      ctx.fillText(\"fps \" + Math.round(1000 / realDeltaTime), 20, 130);\n    }\n  }\n  // ===============================================================\n  // end of main cycle\n  // ===============================================================\n\n  function updateDeltaTime() {\n    currentUpdateTime = Date.now();\n    realDeltaTime = currentUpdateTime - lastUpdateTime;\n    deltaTime = realDeltaTime * TIME_SCALE;\n    lastUpdateTime = currentUpdateTime;\n  }\n\n  // pre render a low fedelity version of the image when zoom to acheive the smooth animation\n  function cacheLowfidelityRender(img, scaleFactor) {\n    const preRenderCanvas = document.createElement(\"canvas\");\n    preRenderCanvas.width = img.width * scaleFactor;\n    preRenderCanvas.height = img.height * scaleFactor;\n\n    preRenderCanvas\n      .getContext(\"2d\")\n      .drawImage(img, 0, 0, preRenderCanvas.width, preRenderCanvas.height);\n\n    return preRenderCanvas;\n  }\n\n  function renderPos(ctx, label, value, x, y) {\n    ctx.fillText(label + \" x \" + value.x.toFixed(2), x, y);\n    ctx.fillText(label + \" y \" + value.y.toFixed(2), x, y + 15);\n  }\n\n  function renderImages(ctx, imgs, lowQuality) {\n    let currentCol = 0;\n    let currentRow = 0;\n\n    let currentRowHeight = 0;\n\n    let currentDrawY = 0;\n    let currentDrawX = 0;\n    for (let i = 0; i < imgs.length; i++) {\n      const isImageInBound = isRectInBound(\n        currentDrawX,\n        currentDrawY,\n        imgs[i].width,\n        imgs[i].height\n      );\n      if (isImageInBound) {\n        // render all the images\n        if (lowQuality || currentZoom < 0.5) {\n          // if the zoom is too small, we don't need recalcualte the high quality\n          ctx.drawImage(\n            lowFidelityImges[i],\n            currentDrawX,\n            currentDrawY,\n            imgs[i].width,\n            imgs[i].height\n          );\n        } else {\n          // only render high quality image if the img is in bound\n          ctx.drawImage(imgs[i], currentDrawX, currentDrawY);\n        }\n      }\n\n      // CALCULATE THE LAYOUT FOR NEXT IMAGE\n\n      // update the row height if necessary\n      if (imgs[i].height > currentRowHeight) currentRow = imgs[i].height;\n\n      // increment column\n      currentDrawX += imgs[i].width + paddingBetweenImages;\n\n      if (currentCol < documentColCount - 1) {\n        // if not at the end of row\n\n        currentCol++;\n      } else {\n        // if reached the end of row\n\n        // increment row\n        currentDrawY += currentRow + paddingBetweenImages;\n        currentRow++;\n\n        // reset col pos\n        currentDrawX = 0;\n        currentCol = 0;\n\n        // reset row height\n        currentRow = 0;\n      }\n    }\n  }\n\n  function isCameraMoving() {\n    return (\n      currentCameraVel.x.toFixed(2) != 0 || currentCameraVel.y.toFixed(2) != 0\n    );\n  }\n\n  function isRectInBound(x, y, w, h) {\n    let viewportWidthInWorld = canvas.width / currentZoom;\n    let viewportHeightInWorld = canvas.height / currentZoom;\n    return (\n      x < currentCameraPos.x + viewportWidthInWorld &&\n      x + w > currentCameraPos.x &&\n      y < currentCameraPos.y + viewportHeightInWorld &&\n      y + h > currentCameraPos.y\n    );\n  }\n  function checkCollisionRect(x, y, w, h, x2, y2, w2, h2) {\n    return x < x2 + w2 && x + w > x2 && y < y2 + h2 && y + h > y2;\n  }\n\n  // mapping of screen position to world position\n  function screenToWorldPos(screenPos) {\n    return {\n      x: screenPos.x / currentZoom + currentCameraPos.x,\n      y: screenPos.y / currentZoom + currentCameraPos.y,\n    };\n  }\n\n  function worldToScreenPos(worldPos) {\n    // word coordinate would be\n    return {\n      x: (worldPos.x - currentCameraPos.x) * currentZoom,\n      y: (worldPos.y - currentCameraPos.y) * currentZoom,\n    };\n  }\n\n  function clamp(value, min, max) {\n    if (value < min) return min;\n    if (value > max) return max;\n    return value;\n  }\n\n  return createViewportRenderer(_canvas);\n}\nexport default ViewportRenderer;\n","/*\n * this componenet handles\n * 1 - User Input for munipulation of the viewport\n * 2 - loading of the image files\n * 3 - managing the ViewportRenderer\n */\n\nimport React, { useState, useRef, useEffect } from \"react\";\nimport { PropTypes } from \"prop-types\";\nimport ViewportRenderer from \"./ViewportRenderer.js\";\nimport \"./Viewport.scss\";\n\nlet _imageLoaded = false;\n\n// Canvas Implementation of the\nfunction Viewport(props) {\n  const canvasWidth = props.width;\n  const canvasHeight = props.height;\n\n  const [mouseHovering, setMouseHovering] = useState(false);\n\n  // control zooming\n  const ZOOM_SPEED_FACTOR = 0.005;\n  const MAX_ZOOM = 1.5;\n  const MIN_ZOOM = 0.2;\n  const zoom = useRef(1);\n\n  // control panning\n  // const [dragging, setDragging] = useState(false);\n  const PAN_SPEED_FACTOR = 5;\n  const dragging = useRef(false);\n  const mousePosition = useRef({ x: 0, y: 0 });\n\n  // the canvas element\n  const [viewportPosition, setViewportPosition] = useState({ x: 0, y: 0 }); // the coordinate of the canvas element on page\n  const canvasRef = useRef(null);\n\n  //sections\n  const viewportRendererRef = useRef(null);\n\n  function mouseDownHandler(e) {\n    // enter the moving state\n    e.stopPropagation();\n    e.preventDefault();\n\n    // enter dragging mode\n    dragging.current = true;\n  }\n\n  function mouseUpHandler(e) {\n    // exit dragging mode\n    dragging.current = false;\n  }\n\n  function mouseWheelHandler(e) {\n    // trigger pinch to zoom with \"ctrl key\"\n    //https://stackoverflow.com/questions/15416851/catching-mac-trackpad-zoom\n\n    if (e.nativeEvent.ctrlKey || e.nativeEvent.metaKey) {\n      // calculate zoom value\n      const newZoomValue =\n        zoom.current - e.nativeEvent.deltaY * ZOOM_SPEED_FACTOR;\n\n      // set the zoom level\n      zoom.current = clamp(newZoomValue, MIN_ZOOM, MAX_ZOOM);\n\n      // callback for the zoom\n      if (props.onZoom) props.onZoom(zoom.current);\n    } else {\n      if (props.scrollToPan) {\n        // pan the camera around base on the scroll\n        const currentCameraPos = viewportRendererRef.current.getCurrentCameraPos();\n\n        viewportRendererRef.current.pointCameraTo({\n          x:\n            currentCameraPos.x +\n            (e.nativeEvent.deltaX * PAN_SPEED_FACTOR) / zoom.current,\n          y:\n            currentCameraPos.y +\n            (e.nativeEvent.deltaY * PAN_SPEED_FACTOR) / zoom.current,\n        });\n      }\n    }\n    return false;\n  }\n\n  function mouseMoveHandler(e) {\n    // if (dragging) {\n    // grab the mouse position relative to the canvas top left\n    // and save it to the mousePosition ref\n    mousePosition.current = {\n      x: e.nativeEvent.pageX - viewportPosition.x,\n      y: e.nativeEvent.pageY - viewportPosition.y,\n    };\n    // }\n  }\n\n  function mouseOverHandler(e) {\n    // lock trackpad panning when the user mouse over this element\n    setMouseHovering(true);\n  }\n\n  function mouseOutHandler(e) {\n    setMouseHovering(false);\n  }\n\n  useEffect(() => {\n    function gestureStartHandler(e) {\n      e.preventDefault();\n      // when the the user start moving with the trackpad\n      // the viewport start panning\n    }\n\n    function gestureEndHandler(e) {\n      e.preventDefault();\n    }\n    // create event listener for handling trackpad panning\n    canvasRef.current.addEventListener(\"touchstart\", gestureStartHandler);\n    canvasRef.current.addEventListener(\"touchend\", gestureEndHandler);\n    return () => {\n      canvasRef.current.removeEventListener(\"touchstart\", gestureStartHandler);\n      canvasRef.current.removeEventListener(\"touchend\", gestureEndHandler);\n    };\n  }, []);\n\n  useEffect(() => {\n    // calculate canvas position when state changes\n    const canvasRect = canvasRef.current.getBoundingClientRect();\n    setViewportPosition({\n      // you need to add scroll position to get the accurate value\n      // because sometimes the page loaded on at the top, but at the middle\n      x: window.scrollX + canvasRect.left,\n      y: window.scrollY + canvasRect.top,\n    });\n    // console.log(\"viewport position:\");\n    // console.log(viewportPosition);\n  }, []);\n\n  useEffect(() => {\n    // initialise the canvas\n    const viewportRenderer = ViewportRenderer(canvasRef.current);\n\n    // Load the svg files\n    let loadedImage = 0;\n    const imgList = props.sections.map((currentSection) => {\n      // section:\n      // - title:string\n      // - src:string\n      const img = new Image();\n      const imgUrl = currentSection.src;\n      img.src = imgUrl;\n      img.addEventListener(\"load\", () => {\n        console.log(\"Viewport loaded image: \" + imgUrl);\n        loadedImage++;\n\n        if (loadedImage === imgList.length) {\n          // all the image is loaded\n          _imageLoaded = true;\n\n          console.log(\"All images loaded, initialize ViewportRenderer\");\n\n          // initialize the viewport renderer using the loaded image list\n          viewportRenderer.initialize(imgList, props.cols, zoom.current);\n        }\n      });\n\n      return img;\n    });\n\n    // the canvas animation loop begins here\n    const update = (deltaTime) => {\n      if (viewportRenderer.isInitialized()) {\n        viewportRenderer.update(\n          mousePosition.current,\n          zoom.current,\n          dragging.current\n        );\n      }\n\n      requestAnimationFrame(update);\n    };\n    // begin the update cycle\n    update();\n\n    viewportRendererRef.current = viewportRenderer;\n  }, []); // no depency, make sure the code is only called once\n\n  useEffect(() => {\n    //go to target section when the target section changes\n    // get target section image index\n    const targetSectionIndex = props.sections.findIndex(\n      (item) => item.title === props.targetSection\n    );\n    console.log(\"going to target section: \" + props.targetSection);\n\n    // jump to that section\n    viewportRendererRef.current.pointCameraToImage(targetSectionIndex);\n  }, [props.targetSection]);\n\n  useEffect(() => {\n    if (!mouseHovering) return;\n    const preventDefaultWheelBehaviour = (e) => {\n      // stop the document from scrolling when the user mouse over this\n\n      // the scrolltopan is enabled or the user is zooming in using their mouse\n      if (props.scrollToPan || e.ctrlKey || e.metaKey) e.preventDefault();\n    };\n    window.addEventListener(\"wheel\", preventDefaultWheelBehaviour, {\n      passive: false,\n    });\n    return () => {\n      window.removeEventListener(\"wheel\", preventDefaultWheelBehaviour);\n    };\n  }, [mouseHovering]);\n\n  // this effect handle when the user\n  useEffect(() => {\n    if (props.targetZoom) {\n      zoom.current = props.targetZoom;\n\n      // mouse is on the control, meaning that the source is come from the control\n      if (!mouseHovering) {\n        // const currentCameraPos = viewportRendererRef.current.getCurrentCameraPos();\n        const currentScreenCenterInWorld = viewportRendererRef.current.screenToWorldPos(\n          {\n            x: canvasWidth / 2,\n            y: canvasHeight / 2,\n          }\n        );\n\n        mousePosition.current = viewportRendererRef.current.worldToScreenPos({\n          x: clamp(\n            currentScreenCenterInWorld.x,\n            canvasWidth / 2,\n            viewportRendererRef.current.getDocumentWidth()\n          ),\n          y: clamp(\n            currentScreenCenterInWorld.y,\n            canvasHeight / 2,\n            viewportRendererRef.current.getDocumentHeight()\n          ),\n        });\n      }\n    }\n  }, [props.targetZoom]);\n  return (\n    <canvas\n      style={{ touchAction: \"none\" }}\n      onMouseDown={mouseDownHandler}\n      onMouseUp={mouseUpHandler}\n      onMouseMove={mouseMoveHandler}\n      onMouseOver={mouseOverHandler}\n      onMouseOut={mouseOutHandler}\n      onWheel={mouseWheelHandler}\n      ref={canvasRef}\n      width={canvasWidth}\n      height={canvasHeight}\n    />\n  );\n}\n\n// the component take in these props\nViewport.propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  targetZoom: PropTypes.number,\n  targetSection: PropTypes.string,\n  sections: PropTypes.arrayOf(\n    PropTypes.shape({\n      title: PropTypes.string,\n      src: PropTypes.string,\n    })\n  ),\n  cols: PropTypes.number, // specify how much columns in the layout\n  onZoom: PropTypes.func,\n  scrollToPan: PropTypes.bool,\n};\n\nfunction clamp(value, min, max) {\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n}\n\n// utitlitiy to detect wether its trackpad or mouse input\n// https://stackoverflow.com/questions/10744645/detect-touchpad-vs-mouse-in-javascript\nfunction detectTrackPad(e) {\n  var isTrackpad = false;\n  if (e.wheelDeltaY) {\n    if (Math.abs(e.wheelDeltaY) !== 120) {\n      isTrackpad = true;\n    }\n  } else if (e.deltaMode === 0) {\n    isTrackpad = true;\n  }\n  return isTrackpad;\n}\n\nexport default Viewport;\n\n//resources\n\n// using SVG and canvas\n// https://levelup.gitconnected.com/draw-an-svg-to-canvas-and-download-it-as-image-in-javascript-f7f7713cf81f\n\n// using canvas and react hooks\n// https://itnext.io/using-react-hooks-with-canvas-f188d6e416c0\n","import Viewport from \"./Viewport.js\";\nexport default Viewport;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport \"./ZoomControl.scss\";\n\nfunction ZoomControl(props) {\n  const defaultZoomLevel = props.defaultZoomLevel\n    ? props.defaultZoomLevel\n    : 100;\n  const zoomLevel = Math.floor(props.zoomLevel);\n  const zoomInterval = 25;\n  const MAX_ZOOM = 150;\n  const MIN_ZOOM = 20;\n\n  function reset() {\n    if (props.onZoomChange) props.onZoomChange(defaultZoomLevel);\n  }\n  function zoomIn() {\n    // calculate next zoom level\n    const remaindingZoomLevel = zoomLevel % zoomInterval;\n    const newZoom = zoomLevel - remaindingZoomLevel + zoomInterval;\n    if (props.onZoomChange)\n      props.onZoomChange(newZoom > MAX_ZOOM ? MAX_ZOOM : newZoom);\n  }\n  function zoomOut() {\n    // calculate next zoom level\n    const remaindingZoomLevel = zoomLevel % zoomInterval;\n    const newZoom = zoomLevel - remaindingZoomLevel - zoomInterval;\n    if (props.onZoomChange)\n      props.onZoomChange(newZoom < MIN_ZOOM ? MIN_ZOOM : newZoom);\n  }\n\n  return (\n    <div\n      className={\n        zoomLevel === defaultZoomLevel\n          ? \"zoom-control\"\n          : \"zoom-control zoom-control--mutated\"\n      }\n    >\n      <button className=\"zoom-control__reset\" onClick={reset}>\n        Reset Zoom\n      </button>\n      <button onClick={zoomIn}>+</button>\n      <div className=\"zoom-control__value\">{zoomLevel}%</div>\n      <button onClick={zoomOut}>-</button>\n    </div>\n  );\n}\n\nZoomControl.propTypes = {\n  onZoomChange: PropTypes.func,\n};\n\nexport default ZoomControl;\n","import ZoomControl from \"./ZoomControl.js\";\nexport default ZoomControl;\n","import React, { useCallback, useRef } from \"react\";\nimport { useState, useEffect } from \"react\";\nimport { PropTypes } from \"prop-types\";\nimport Viewport from \"./viewport\";\nimport \"./DesignExplorer.scss\";\nimport ZoomControl from \"../zoomControl\";\n\nfunction DesignExplorer(props) {\n  const imgList = props.src;\n\n  const defaultZoomLevel = props.initialZoom || 100;\n  const [zoomLevel, setZoomLevel] = useState(props.initialZoom || 100);\n  const [viewportSize, setWindowSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  const [viewingSection, setCurrentViewingSection] = useState(\"\");\n\n  // zoom hint message\n  const ZOOM_HINT_TIME = 500;\n  const [zoomInteractionHint, setZoomInteractionHint] = useState(false);\n  const zoomHintTimer = useRef(null);\n  const mouseInComponent = useRef(false);\n\n  const containerRef = useRef(null);\n\n  const sectionNames = [\n    \"Viewing your tasks\",\n    \"Contacting a client\",\n    \"Contacting a helper\",\n    \"Leaderboard\",\n    \"Check in - Before\",\n    \"Check in - During and after\",\n    \"Leaving Reviews\",\n  ];\n  var sections = imgList.map((val, index) => {\n    return {\n      title: sectionNames[index],\n      src: val,\n    };\n  });\n\n  // for testing the platform so it shows the correct hints\n  // https://stackoverflow.com/questions/10527983/best-way-to-detect-mac-os-x-or-windows-computers-with-javascript-or-jquery\n  function isMacintosh() {\n    return navigator.platform.indexOf(\"Mac\") > -1;\n  }\n\n  function isWindows() {\n    return navigator.platform.indexOf(\"Win\") > -1;\n  }\n\n  function mouseEnterHandler() {\n    mouseInComponent.current = true;\n  }\n  function mouseOutHandler() {\n    mouseInComponent.current = false;\n  }\n\n  function viewportZoomHandler(zoom) {\n    setZoomLevel(zoom * 100);\n  }\n\n  function zoomChangeHandler(zoomLevel) {\n    setZoomLevel(zoomLevel);\n  }\n\n  function scrollHandler(e) {\n    // if the mouse is inside and the use didnt hold down the zoom modifer key\n    if (mouseInComponent.current && (!e.ctrlkey || !e.metaKey)) {\n      setZoomInteractionHint(true);\n\n      // How do I know when I've stopped scrolling?\n      //https://stackoverflow.com/questions/4620906/how-do-i-know-when-ive-stopped-scrolling\n\n      // if the timer exist already(menaing the user still scrolling wihtout zooming)\n      // show reset the timer\n      if (zoomHintTimer.current != null) clearTimeout(zoomHintTimer.current);\n\n      // set a timer for how long the zoom hint text display\n      zoomHintTimer.current = setTimeout(\n        () => setZoomInteractionHint(false),\n        ZOOM_HINT_TIME\n      );\n    } else {\n      setZoomInteractionHint(false);\n    }\n  }\n\n  function windowResizeHandler() {\n    // refresh the window size\n    setWindowSize({\n      width: containerRef.current.offsetWidth,\n      height: containerRef.current.offsetHeight,\n    });\n  }\n\n  function hashChangeHandler() {\n    setCurrentViewingSection(\n      decodeURIComponent(window.location.hash.split(\"#\")[1])\n    );\n  }\n  useEffect(() => {\n    window.addEventListener(\"resize\", windowResizeHandler);\n    window.addEventListener(\"hashchange\", hashChangeHandler);\n    window.addEventListener(\"scroll\", scrollHandler);\n    return () => {\n      window.removeEventListener(\"resize\", windowResizeHandler);\n      window.removeEventListener(\"hashchange\", hashChangeHandler);\n      window.removeEventListener(\"scroll\", scrollHandler);\n    };\n  }, []);\n\n  // init the viewport size base on the container size\n  useEffect(() => {\n    setWindowSize({\n      width: containerRef.current.offsetWidth,\n      height: containerRef.current.offsetHeight,\n    });\n  }, [containerRef]);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"design-explorer-container\"\n      onMouseEnter={mouseEnterHandler}\n      onMouseOut={mouseOutHandler}\n    >\n      <div className=\"credit-text\">Crafted with ReactJS by Alvin Leung</div>\n      <ZoomControl\n        zoomLevel={zoomLevel}\n        onZoomChange={zoomChangeHandler}\n        defaultZoomLevel={defaultZoomLevel}\n      />\n      <div className=\"viewport-container\">\n        <Viewport\n          width={viewportSize.width}\n          height={viewportSize.height}\n          src={imgList}\n          sections={sections}\n          targetSection={viewingSection}\n          targetZoom={zoomLevel / 100}\n          onZoom={viewportZoomHandler}\n          cols={props.cols ? props.cols : 1}\n          scrollToPan={props.scrollToPan ? props.scrollToPan : false}\n        />\n      </div>\n      <div\n        className={\n          zoomInteractionHint\n            ? \"zoom-interaction-hint\"\n            : \"zoom-interaction-hint zoom-interaction-hint--hidden\"\n        }\n      >\n        {isWindows() && <span>Hold Ctrl and scroll to zoom in</span>}\n        {isMacintosh() && <span>Hold &#8984; and scroll to zoom in</span>}\n      </div>\n    </div>\n  );\n}\n\nDesignExplorer.propTypes = {\n  scrollToPan: PropTypes.bool,\n  src: PropTypes.array,\n  cols: PropTypes.number, // the amount of columns in the layout\n  initialZoom: PropTypes.number,\n};\n\nexport default DesignExplorer;\n","import DesignExplorer from \"./designExplorer.js\";\nexport default DesignExplorer;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n// import \"./index.css\";\n// import App from \"./App\";\nimport DesignExplorer from \"./components/designExplorer\";\n// import * as serviceWorker from \"./serviceWorker\";\n\n// const imgList = [\n//   `${process.env.PUBLIC_URL}/img/8 Viewing your tasks.svg`,\n//   `${process.env.PUBLIC_URL}/img/9 Contacting a client.svg`,\n//   `${process.env.PUBLIC_URL}/img/10 Contacting a helper.svg`,\n//   `${process.env.PUBLIC_URL}/img/11 Leaderboard.svg`,\n//   `${process.env.PUBLIC_URL}/img/12 Check in - Before.svg`,\n//   `${process.env.PUBLIC_URL}/img/13 Check in - During and after.svg`,\n//   `${process.env.PUBLIC_URL}/img/14 Leaving Reviews.svg`,\n// ];\n\n// ReactDOM.render(\n//   <React.StrictMode>\n//     <App />\n//   </React.StrictMode>,\n//   document.getElementById(\"root\")\n// );\n\n// grab all the viewer elements on html\nwindow.addEventListener(\"load\", function () {\n  const designExplorerList = document.querySelectorAll(\".design-explorer\");\n  designExplorerList.forEach((elm) => {\n    // const srcListAttribute = elm.getAttribute(\"data-src\").replaceAll(\"'\", '\"');\n\n    // also grab all the image elmeents in the\n    const allImgTag = elm.querySelectorAll(\"img\");\n\n    let srcList = [];\n    for (let i = 0; i < allImgTag.length; i++) {\n      srcList[i] = allImgTag[i].src;\n    }\n\n    // const srcList = JSON.parse(srcListAttribute);\n\n    const colCountAttribute = parseInt(elm.getAttribute(\"data-cols\") || 1);\n\n    const colInitialZoomAttribute = parseInt(\n      elm.getAttribute(\"data-init-zoom\") || 100\n    );\n\n    console.log(\"test\");\n    ReactDOM.render(\n      <DesignExplorer\n        src={srcList}\n        cols={colCountAttribute}\n        scrollToPan={false}\n        initialZoom={colInitialZoomAttribute}\n      />,\n      elm\n    );\n  });\n});\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}